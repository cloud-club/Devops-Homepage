![도커](/Devops-Homepage/chan/image/%EB%8F%84%EC%BB%A4.jpg)

Chapter 4
=========
쿠버네티스를 이루는 컨테이너 도우미, 도커
------------------------------------------

---
# 0. 도커를 알아야 하는 이유
### **도커를 자세히 알면 컨테이너 인프라 환경을 깊게 이해할 수 있다.** 

> **파드**는 쿠버네티스로부터 IP를 받아 컨테이너가 외부와 통신할 수 있는 경로를 제공하고 컨테이너들이 정상적으로 작동하는지 확인하고 네트워크나 저장 공간을 서로 공유하게 합니다.

> 컨테이너를 돌보는 것이 **파드** 
> 파드를 돌보는 것이 **쿠버네티스 워커 노드**
> 워커 노드를 돌보는 것이 **쿠버네티스 마스터**, 쿠버네티스 마스터 역시 파드(컨테이너로 이루어짐)

> **컨테이너**는 하나의 운영 체제 안에서 커널을 공유하며 개별적인 실행 환경을 제공하는 격리된 공간이다.
> **개별적인 실행환경**은 CPU, 네트워크, 메모리와 같은 시스템 자원을 독립적으로 사용하도록 할당된 환경을 말합니다. ID도 격리돼 관리됩니다. 따라서, 독립적.

---

# 1. 도커로 컨테이너 다루기
### **[ 이미지 찾기 -> 실행하기 -> 디렉터리와 연결하기 -> 삭제하기 ]** 

> 컨테이너 이미지는 그대로 사용할 수 없고, 도커와 같은 CRI로 불러들여야 컨테이너가 실제로 동작한다.
> **실행 파일과 실행된 파일 관계**로 볼 수 있다.
> 따라서, 컨테이너를 삭제할 때는 내려받은 이미지와 이미 실행된 컨테이너를 모두 삭제해야만 디스크의 용량을 온전히 확보할 수 있다.

#

### **이미지 검색하고 내려받기**
> 이미지는 레지스트리 저장소에 모여 있다.
> **레지스트리**는 도커 허브처럼 공개된 유명 레지스트리일 수도 있고, 내부에 구축한 레지스트리일 수도 있다.
> 별도의 레지스트리를 지정하지 않으면 기본으로 도커 허브에서 이미지를 찾는다.

```
# 현재 사용할 수 있는 nginx 이미지 찾기
docker search nginx
```
**INDEX** : 이미지가 저장된 레지스트리 이름
**STARS** : 해당 이미지를 내려받은 사용자에게 받은 평가 횟수
**OFFICIAL** : [OK] 표시는 해당 이미지에 포함된 애플리케이션, 미들웨어 등을 개발한 업체에서 공식적으로 제공한 이미지라는 의미.
**AUTOMATED** : [OK] 표시는 도커 허브에서 자체적으로 제공하는 이미지 빌드 자동화 기능을 활용해 생성한 이미지를 의미.

```
# 이미지 내려받기
docker pull nginx
```

#### **이미지 태그**
> 태그는 이름이 동일한 이미지에 추가하는 식별자.
> 이름이 동일해도 도커 이미지의 버전이나 플랫폼이 다를 수 있기 때문에 이를 구분하는데 사용.
> 태그를 명시하지 않으면 latest 태그를 기본으로 사용한다.
>  => 따라서, 위 명령을 실행하면 latest 버전의 nginx 이미지를 내려받게 된다.
> 참고로, 컨테이너를 배포할 때는 latest 태그가 아닌 검증된 버전으로 배포해야 문제가 생기지 않는다.

#### **이미지 레이어 구조**
> 사실 이미지는 애플리케이션과 각종 파일을 담고 있다는 점에서 ZIP과 같은 압축 파일에 더 가깝다.
> 압축 파일은 압축한 파일의 개수에 따라 전체 용량이 증가하지만, 이미지는 같은 내용일 경우 여러 이미지에 **동일한 레이어를 공유**하므로 전체 용량이 감소한다.
> 이처럼 도커로 작성된 컨테이너는 레이어를 재사용하기 떄문에 여러 이미지를 내려받더라도 디스크 용량을 효율적으로 사용할 수 있다.

```
# 내려받은 이미지 조회
docker images <이미지 이름>
docker images nginx

# nginx:stable 이미지가 어떤 과정을 거쳐 생성됬는지 확인
docker history nginx:stable
```
# 

### **이미지 실행하기**
```
# 내려받은 이미지를 기반으로 새로운 컨테이너 실행
docker run -d --restart always nginx
```
> **-d(--detach)**: 컨테이너를 백그라운드에서 구동
> **--restart always**: 프로그램에서 예상치 못한 오류가 발생하거나 리눅스 시스템에서 도커 서비스가 중지되는 경우에는 컨테이너도 작동이 중지된다. 이때 중지된 컨테이너를 자동으로 시작되게 설정하는 옵션

```
# 생성된 컨테이너 상태 확인
docker ps
# 컨테이너를 지정해 검색 (컨테이너 아이디에 cec7 포함된 것)
# docker ps -f id=cec7
```
> **-f(--filter)** : 이 때 대상을 지정할 떄는 key=value 형식으로 입력함.
>> ***필터링에 사용하는 주요키들***
>> [id, name, label, exited, status, ancestor]
>>> exited : 컨테이너가 종료됐을 때 반환하는 숫자 코드
>>> ancestor : 컨테이너가 사용하는 이미지

#
```
# 생성된 nginx 컨테이너는 마스터 노드 내부에 존재하므로,
# 컨테이너가 제공하는 nginx 웹 페이지 정보가 보고 싶다면
curl 127.0.0.1
# 생성한 컨테이너는 80번 포트를 사용하므로 HTTP의 기본 포트인 80번 포트로 요청을 보냄.

==> Connection Failed
```
> **결과는 Fail.**
> 앞에서 컨테이너의 PORTS 열에 표시되는 **80/TCP**는 컨테이너 내부에서 TCP 프로토콜의 80번 포트를 사용한다는 의미다. 하지만 curl 127.0.0.1로 전달한 요청은 로컬호스트(127.0.0.1)의 80번 포트로 전달만 될 뿐, 컨테이너까지는 도달하지 못한다.
> ***즉, 호스트에 도달한 후 컨테이너로 도달하기 위한 추가 경로 설정이 되어있지 않아서.***
> #
> **이제 컨테이너 외부에서도 컨테이너 내부에 접속할 수 있게 새로운 컨테이너를 구동해보자.**
> 80번으로 들어온 것을 컨테이너에서 받아줄 수 있는 포트로 연결해주는 설정 추가.
> #
> ***컨테이너는 변경 불가능한 인프라***를 지향하기 때문에, 작동 중일 때 설정을 변경할 수 없다.

```
# -p <요청 받을 호스트 포트>:<연결할 컨테이너 포트>
docker run -d -p 8080:80 --name nginx-exposed --restart always nginx
```
>> **-p (--publish)** : 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달하는 옵션
```
# 컨테이너가 제대로 작동하는지 확인
docker ps -f name=nginx-exposed
```
> PORTS 부분에 0.0.0.0:8080->80/tcp 라 나와 있음.
> 0.0.0.0의 8080번 포트로 들어오는 요청을 컨테이너 내부의 80번 포트로 전달.
> 0.0.0.0은 존재하는 모든 네트워크 어댑터를 의미.
> m-k8s 호스트는 자기 자신을 나타내는 127.0.0.1과 외부에 노출된 192.168.1.10 등의 IP를 가지고 있는데, 요청이 호스트에 할당된 어떤 IP의 8080번 포트로 들어오더라도 컨테이너 내부의 80번 포트로 전달한다.
> ### 
> 현재 nginx 내부에는 따로 작성한 파일이 없기 때문에, 192.168.1.10:8080으로 접속하면 기본 웹페이지가 보여진다. 컨테이너 내부에서 웹 페이지 파일을 변경할 수 있지만 이런 경우 컨테이너를 다시 생성하게 되면 매번 웹 페이지 파일을 전송해야 한다.
> 그러므로 **영속적인 웹 페이지 파일을 사용하기 위해서는 특정 디렉터리와 컨테이너 내부의 디렉터리를 연결하는 것이 효과적**이다.
#
### **컨테이너 내부 파일 변경하기**
#### **도커는 컨테이너 내부에서 외부의 파일을 사용할 수 있는 방법으로 4가지를 제공.**

* #### 1). docker cp
> 호스트에 위치한 파일을 구동 중인 컨테이너에 복사.
> 따라서 임시로 필요한 파일이 있는 경우 단편적으로 전송하기 위해 사용.
> 또는 컨테이너에 저장돼 있는 설정 및 로그를 추출해 확인하는 목적으로도 사용.
```
docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로>
```
* #### 2). Dockerfile ADD
> 이미지는 Dockerfile을 기반으로 만들어지는데, 이때 Dockerfile에 ADD라는 구문으로 컨테이너 내부로 복사할 파일을 저장하면 **이미지를 빌드할 때 지정한 파일이 이미지 내부로 복사됨**
> 해당 이미지를 기반으로 구동한 컨테이너에서는 복사한 파일을 사용할 수 있음.
> 사용자가 원하는 파일을 선택해 사용할 수 없다는 것이 단점.
* #### 3). 바인드 마운트
> 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한 쪽에서 작업한 내용이 양쪽에 동시에 반영됨.
> 새로운 컨테이너를 구동할 때도 호스트와 연결할 파일이나 디렉터리의 경로만 지정하면 다른 컨테이너에 있는 파일을 새로 생성한 컨테이너와 연결할 수 있다.
> 데이터베이스의 데이터 디렉터리나 서버의 첨부 파일 디렉터리처럼 컨테이너가 바뀌어도 없어지면 안되는 자료는 이 방법으로 보존할 수 있다.
```
<< -------------바인드 마운트로 호스트와 컨테이너 연결 ---------------->>

01. 컨테이너 내부에 연결할 /root/html/ 디렉터리를 호스트에 생성
[root@m-k8s ~]# mkdir -p /root/html

02. nginx-bind-mounts라는 컨테이너를 구동하고, 컨테이너의 /usr/share/nginx/html 디렉터리와 호스트의 /root/html 디렉터리 연결.
docker run -d -p 8081:80\
-v /root/html:/usr/share/nginx/html --restart always --name nginx-bind-mounts nginx

03. nginx-bind-mounts 컨테이너 상태가 정상인지 확인
docker ps -f nginx-bind-mounts

# 이때 컨테이너 내부와 연결된 /root/html 디렉터리는 비워 있기 때문에,
# nginx에 접속하면 403 forbidden 이 나타남.

04. index.html을 /root/html에 복사
cp ~/_Book_k8sInfra/ch4/4.2.3/index-BindMount.html /root/html/index.html
ls /root/html

# nginx에 접속하면 index.html의 내용이 표시됨.
```
> **-v(--volume)**: 호스트 디렉터리와 컨테이너 디렉터리를 연결하는 옵션.
> 호스트 디렉터리의 내용을 그대로 컨테이너 디렉터리에 덮어씀.
> 따라서 컨테이너에 어떤 내용이 이미 있어도 해당 내용은 삭제된다.
```
# 컨테이너 내부 확인
docker exec <컨테이너의 ID|이름> <명령어>
docker exec e7ca ls /usr/share/nginx/html
```
* #### 4). 볼륨
> 호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일하지만, 호스트의 특정 디렉터리가 아닌 **도커가 관리하는 볼륨을 컨테이너와 연결.**
> 여기서 말하는 볼륨은 쿠버네티스의 볼륨 구조와 유사.
> 도커가 관리하는 볼륨 공간을 NFS와 같은 공유 디렉터리에 생성한다면 다른 호스트에서도 도커가 관리하는 볼륨을 함께 사용할 수 있다.
```
<< -------------볼륨으로 호스트와 컨테이너 연결 ---------------->>

01. 볼륨 생성 # 도커가 직접 관리하며 컨테이너에 제공하는 호스트의 공간
docker volume create nginx-volume

02. 생성된 볼륨 조회
docker volume inspect nginx-volume
# 여기서 Mountpoint행 확인 -> 해당 디렉터리가 볼륨 디렉터리니까.

03. 볼륨으로 생성된 디렉터리 확인
ls /var/lib/docker/volume/nginx-volume/_data
# 위 mountpoint행에 있던 디렉터리

04. 호스트와 컨테이너의 디렉터리를 연결할 컨테이너 구동
docker run -d -p 8082:80 -v nginx-volume:/usr/share/nginx/html \
--restart always --name nginx-volume nginx
# 컨테이너 내부의 /usr/share/nginx/html 디렉터리와 호스트의 nginx-volume 볼륨 연결.
```
> 바인드 마운트와 달리 호스트 디렉터리를 컨테이너 디렉터리에 덮어쓰지 않고 ***양쪽을 서로 동기화***시킴
> 비어 있는 볼륨을 연결하는 경우에는 컨테이너 디렉터리에 있는 파일이 보존됨.
> 하지만 볼륨에 컨테이너 디렉터리와 동일한 파일이 존재한 상태로 연결하는 경우에는 덮어쓰기가 되니 유의.

#
### **사용하지 않는 컨테이너 정리하기**
```
<< ------------------- 컨테이너 정지하기 -------------------->>

docker ps -f ancestor=nginx

# 컨테이너 정지 => 컨테이너 이름으로
docker stop tender_snyder
# 컨테이너 정지 => 컨테이너 아이디로
docker stop f530

# nginx 이미지를 사용하는 모든 컨테이너 한꺼번에 정지
docker ps -q -f ancestor=nginx
docker stop $(docker ps -q -f ancestor=nginx)---------------
```
> **-q(--quite)**: Container's ID 만 출력

```
<< ------------------- 컨테이너 이미지 삭제 -------------------->>

01. 컨테이너 삭제
docker rm $(docker ps -aq -f ancestor=nginx)

02. 이미지 삭제
docker rmi $(docker images -q nginx)
```












